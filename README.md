							Curso SOLID Alura
                                                          
                                                          
                                                          
Principios orientação a objetos

Coesão - união harmônica entre uma coisa e outra

	Classes não coesas tendem a crescer indefinidamente, 
	o que as tornam difíceis de manter.


Encapsulamento - incluir ou proteger alguma coisa em uma cápsula
	
	Classes não encapsuladas permitem violação de regras
	de negócio, além de aumentarem o acoplamento.


Acoplamento - Ação de acoplar. Agrupamento aos pares

	Classes acopladas causam fragilidade no código
	da aplicação, o que dificulta sua manutenção
	
	
----------------------------------------------------------------------------------------------------------------------------

							Principios SOLID
														
														
Single Responsibility Principle
<br>
Princípio Da Responsabilidade Única

	É um princípio que afirma que cada módulo,classe ou função 
	em um programa de computador deve ter responsabilidade 
	sobre uma única parte da funcionalidade desse programa 
	e deve encapsular essa parte.
	
	
	
Open Closed Principle
<br>
Princípio Aberto Fechado


	O princípio do aberto/fechado estabelece que 
	"entidades de software devem ser abertas para extensão, 
	mas fechadas para modificação"; isto é, 
	a entidade pode permitir que o seu comportamento seja 
	estendido sem modificar seu código-fonte
	
	
Liskov Substitution Principle
<br>
Principio Da Substituição de Liskov

	O princípio tem como objetivo nos alertar quanto a 
	utilização da herança, que é um poderoso mecanismo 
	e deve ser utilizado com extrema parcimônia.
	
	
	
	
Interface Segregation Principle
<br>
Princípio da segregação de Interface

	O princípio da segregação de Interface afirma que 
	nenhum cliente deve ser forçados a depender 
	de métodos que não utiliza.
	
	
	
Dependency Inversion Principle
<br>
Princípio da inversão de dependência

	De uma forma objetiva o princípio nos faz entender 
	que sempre devemos depender de abstrações e não das 
	implementações, afinal de contas, as abstrações mudam 
	menos e facilitam a mudança de comportamento 
	e as evoluções do código.



